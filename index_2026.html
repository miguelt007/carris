<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Carris Metropolitana ‚Äì Live</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
html, body { margin:0; height:100%; font-family: Arial, sans-serif; }
#map { height:100%; width:100%; }

#header {
  position:absolute; top:10px; left:50%; transform:translateX(-50%);
  z-index:1000; background: rgba(0,0,0,0.5); padding:10px 20px; border-radius:10px;
  display:flex; align-items:center; gap:10px; color:white; font-weight:bold; font-size:18px;
  box-shadow:0 4px 10px rgba(0,0,0,0.3);
}
.live-indicator { width:12px; height:12px; background:#27ae60; border-radius:50%; animation:blink 1s infinite; }
@keyframes blink { 0%,50%,100%{opacity:1;} 25%,75%{opacity:0.2;} }

#botao-centro {
  position:absolute; bottom:20px; right:20px; z-index:999;
  background:white; border:2px solid #333; border-radius:50%; width:48px; height:48px;
  font-size:24px; text-align:center; line-height:44px; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.3);
}
.leaflet-popup-content { max-height:250px; overflow-y:auto; }
</style>
</head>
<body>

<div id="header">
  <span class="live-indicator"></span> Carris Metropolitana ‚Äì Live
</div>
<div id="map"></div>
<button id="botao-centro">&#9673;</button>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/gh/bbecquet/Leaflet.RotatedMarker@master/leaflet.rotatedMarker.js"></script>
<script>
// Inicializar mapa
const map = L.map('map').setView([38.736946, -9.142685], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
  attribution:'¬© OpenStreetMap contributors'
}).addTo(map);

// Utilizador
let marcadorUtilizador;
navigator.geolocation.watchPosition(pos=>{
  const {latitude,longitude} = pos.coords;
  if(!marcadorUtilizador) marcadorUtilizador = L.marker([latitude,longitude]).addTo(map);
  else marcadorUtilizador.setLatLng([latitude,longitude]);
});
document.getElementById('botao-centro').addEventListener('click',()=>{ if(marcadorUtilizador) map.setView(marcadorUtilizador.getLatLng(),15); });

// Fun√ß√µes utilit√°rias
function traduzirStatus(status){
  switch(status){
    case "INCOMING_AT": return "A chegar √† paragem";
    case "STOPPED_AT": return "Parado na paragem";
    case "IN_TRANSIT_TO": return "Em tr√¢nsito";
    default: return "Desconhecido";
  }
}

function calcularDistanciaKm(lat1, lon1, lat2, lon2){
  const R=6371, dLat=(lat2-lat1)*Math.PI/180, dLon=(lon2-lon1)*Math.PI/180;
  const a=Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  return 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))*R;
}

// Cache de percursos
const cachePatterns = new Map();
async function obterInfoPercurso(pattern_id){
  if(!pattern_id) return {headsign:"n√£o dispon√≠vel",paragens:[],proximaParagem:null};
  if(cachePatterns.has(pattern_id)) return cachePatterns.get(pattern_id);
  try{
    const res = await fetch(`https://api.carrismetropolitana.pt/patterns/${pattern_id}`);
    if(!res.ok) throw new Error();
    const dados = await res.json();
    const headsign = dados?.headsign||"n√£o dispon√≠vel";
    const path = dados?.path||[];
    const paragens = path.map(p=>p.stop?.name).filter(Boolean).slice(0,5);
    const proximaParagem = path.find(p=>p.stop?.lat && p.stop?.lon)?.stop||null;
    const info={headsign,paragens,proximaParagem};
    cachePatterns.set(pattern_id,info);
    return info;
  }catch{return {headsign:"n√£o dispon√≠vel",paragens:[],proximaParagem:null};}
}

// Marcadores existentes com estado
const marcadoresBuses = new Map();

// Fun√ß√£o de √≠cone SVG fixo
function createBusSVGIcon(line){
  const rectWidth = 40;
  const height = 20;
  const padding = 4;
  const arrowWidth = 10;

  const svg = `
  <svg xmlns="http://www.w3.org/2000/svg" width="${rectWidth + arrowWidth}" height="${height}" viewBox="0 0 ${rectWidth + arrowWidth} ${height}">
    <rect x="0" y="0" width="${rectWidth}" height="${height}" fill="#FFD100" stroke="black" rx="3" ry="3"/>
    <text x="${padding}" y="${height/2 + 5}" font-size="12" text-anchor="start" fill="black" font-family="Arial" font-weight="bold">${line}</text>
    <polygon points="${rectWidth},${height/2 - 5} ${rectWidth},${height/2 + 5} ${rectWidth + arrowWidth},${height/2}" fill="black"/>
  </svg>`;
  return L.icon({
    iconUrl: "data:image/svg+xml;base64," + btoa(svg),
    iconSize: [rectWidth + arrowWidth, height],
    iconAnchor: [(rectWidth + arrowWidth)/2, height/2]
  });
}

// Interpola√ß√£o
function lerp(a,b,t){ return a + (b-a)*t; }
function interpolateLatLng(latlng1, latlng2, t){
  return [lerp(latlng1[0],latlng2[0],t), lerp(latlng1[1],latlng2[1],t)];
}

// Anima√ß√£o com requestAnimationFrame
function animateMarker(markerObj, endPos, endAngle, duration){
  const startTime = performance.now();
  const startPos = markerObj.currentPos ? markerObj.currentPos : endPos.slice();
  const startAngle = markerObj.currentAngle != null ? markerObj.currentAngle : endAngle;

  if(markerObj.animationFrameId) cancelAnimationFrame(markerObj.animationFrameId);

  function frame(time){
    const t = Math.min((time - startTime)/duration,1);
    const newPos = interpolateLatLng(startPos,endPos,t);
    const angle = lerp(startAngle,endAngle,t);

    markerObj.marker.setLatLng(newPos);
    markerObj.marker.setRotationAngle(angle);

    markerObj.currentPos = newPos;
    markerObj.currentAngle = angle;

    if(t < 1) markerObj.animationFrameId = requestAnimationFrame(frame);
    else markerObj.animationFrameId = null;
  }

  markerObj.animationFrameId = requestAnimationFrame(frame);
}

// Carregar autocarros com anima√ß√£o suave
async function carregarAutocarros(){
  try{
    const veiculos = await fetch('https://api.carrismetropolitana.pt/vehicles').then(r=>r.json());
    if(!veiculos || !Array.isArray(veiculos)) return;

    veiculos.forEach(async v=>{
      if(!v || !v.lat || !v.lon) return;
      const {lat,lon,id,line_id,speed,bearing,current_status,pattern_id} = v;

      const velocidadeKmH = speed?Math.round(speed*3.6):0;
      const direcao = typeof bearing==="number"?Math.round(bearing)+'¬∞':'n√£o dispon√≠vel';
      const estado = traduzirStatus(current_status);

      // Hora local atual no momento de receber o dado
      const horaFormatada = new Date().toLocaleTimeString("pt-PT", {hour12:false});

      const {headsign,paragens,proximaParagem} = await obterInfoPercurso(pattern_id);
      let tempoEstimado = "n√£o dispon√≠vel";
      if(proximaParagem && velocidadeKmH>0){
        const distKm = calcularDistanciaKm(lat,lon,proximaParagem.lat,proximaParagem.lon);
        const minutos = Math.round((distKm/velocidadeKmH)*60);
        tempoEstimado = `${minutos} min`;
      }

      const popupHTML = `
        üöå <strong>Autocarro ${id}</strong><br>
        <b>Linha:</b> ${line_id}<br>
        <b>Destino:</b> ${headsign}<br>
        <b>Velocidade:</b> ${velocidadeKmH} km/h<br>
        <b>Dire√ß√£o:</b> ${direcao}<br>
        <b>Estado:</b> ${estado}<br>
        <b>Atualiza√ß√£o:</b> ${horaFormatada}<br>
        <b>Tempo estimado at√© pr√≥xima paragem:</b> ${tempoEstimado}<br>
        <br><strong>Pr√≥ximas paragens:</strong><br>${paragens.join('<br>')}
      `;

      if(marcadoresBuses.has(id)){
        const mObj = marcadoresBuses.get(id);
        animateMarker(mObj, [lat,lon], bearing||0, 30000);
        if(mObj.marker._popup) mObj.marker._popup.setContent(popupHTML);
      } else {
        const marker = L.marker([lat, lon], {
          icon:createBusSVGIcon(line_id),
          rotationAngle: bearing || 0,
          rotationOrigin: 'center'
        }).addTo(map);

        marker.bindPopup(popupHTML);

        marcadoresBuses.set(id,{
          marker,
          currentPos: [lat, lon],
          currentAngle: bearing || 0,
          animationFrameId:null
        });
      }
    });
  }catch(err){ console.error('Erro ao carregar ve√≠culos:',err); }
}

// Inicializa
carregarAutocarros();
setInterval(carregarAutocarros,30000);
</script>
</body>
</html>
