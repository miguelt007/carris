<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Carris Metropolitana ‚Äì Live</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
html, body { margin:0; height:100%; font-family: Arial, sans-serif; }
#map { height:100%; width:100%; }

#header {
  position:absolute; top:10px; left:50%; transform:translateX(-50%);
  z-index:1000; background: rgba(0,0,0,0.5); padding:10px 20px; border-radius:10px;
  display:flex; align-items:center; gap:10px; color:white; font-weight:bold; font-size:18px;
  box-shadow:0 4px 10px rgba(0,0,0,0.3);
}
.live-indicator { width:12px; height:12px; background:#27ae60; border-radius:50%; animation:blink 1s infinite; }
@keyframes blink { 0%,50%,100%{opacity:1;} 25%,75%{opacity:0.2;} }

#botao-centro {
  position:absolute; bottom:20px; right:20px; z-index:999;
  background:white; border:2px solid #333; border-radius:50%; width:48px; height:48px;
  font-size:24px; text-align:center; line-height:44px; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.3);
}
.leaflet-popup-content { max-height:250px; overflow-y:auto; }
</style>
</head>
<body>

<div id="header">
  <span class="live-indicator"></span> Carris Metropolitana ‚Äì Live
</div>
<div id="map"></div>
<button id="botao-centro">&#9673;</button>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/gh/bbecquet/Leaflet.RotatedMarker@master/leaflet.rotatedMarker.js"></script>
<script>
// Inicializar mapa
const map = L.map('map').setView([38.736946, -9.142685], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
  attribution:'¬© OpenStreetMap contributors'
}).addTo(map);

// Bot√£o para centrar no utilizador
let marcadorUtilizador;
navigator.geolocation.watchPosition(pos=>{
  const {latitude,longitude} = pos.coords;
  if(!marcadorUtilizador) marcadorUtilizador = L.marker([latitude,longitude]).addTo(map);
  else marcadorUtilizador.setLatLng([latitude,longitude]);
});
document.getElementById('botao-centro').addEventListener('click',()=>{ if(marcadorUtilizador) map.setView(marcadorUtilizador.getLatLng(),15); });

// √çcone retangular com seta e n√∫mero da linha (ajustado)
function createBusSVGIcon(line){
  const maxWidth = 50;
  const height = 20;
  const padding = 4;
  const arrowWidth = 10;

  const rectWidth = Math.min(30 + line.length*6, maxWidth);
  const fontSize = line.length > 4 ? 10 : 12;

  const svg = `
  <svg xmlns="http://www.w3.org/2000/svg" width="${rectWidth+arrowWidth}" height="${height}" viewBox="0 0 ${rectWidth+arrowWidth} ${height}">
    <rect x="0" y="0" width="${rectWidth}" height="${height}" fill="#FFD100" stroke="black" rx="3" ry="3"/>
    <text x="${padding}" y="${height/2 + 5}" font-size="${fontSize}" text-anchor="start" fill="black" font-family="Arial" font-weight="bold">${line}</text>
    <polygon points="${rectWidth},${height/2 - 5} ${rectWidth},${height/2 + 5} ${rectWidth+arrowWidth},${height/2}" fill="black"/>
  </svg>`;
  
  return L.icon({
    iconUrl: "data:image/svg+xml;base64," + btoa(svg),
    iconSize: [rectWidth + arrowWidth, height],
    iconAnchor: [(rectWidth + arrowWidth)/2, height/2]
  });
}

// Fun√ß√£o utilit√°ria para status
function traduzirStatus(status){
  switch(status){
    case "INCOMING_AT": return "A chegar √† paragem";
    case "STOPPED_AT": return "Parado na paragem";
    case "IN_TRANSIT_TO": return "Em tr√¢nsito";
    default: return "Desconhecido";
  }
}

// Fun√ß√£o para dist√¢ncia em km
function calcularDistanciaKm(lat1, lon1, lat2, lon2){
  const R = 6371;
  const dLat = (lat2-lat1)*Math.PI/180;
  const dLon = (lon2-lon1)*Math.PI/180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  const c = 2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
  return R*c;
}

// Armazenar marcadores
const marcadoresBuses = new Map();
const cachePatterns = new Map();

// Interpola√ß√£o linear
function lerp(a,b,t){ return a + (b-a)*t; }
function interpolateLatLng(latlng1, latlng2, t){ return [lerp(latlng1[0],latlng2[0],t), lerp(latlng1[1],latlng2[1],t)]; }

// Anima√ß√£o suave
function animateMarker(mObj, newPos, newAngle, duration=30000){
  const startTime = performance.now();
  const startPos = mObj.currentPos || newPos.slice();
  const startAngle = mObj.currentAngle != null ? mObj.currentAngle : newAngle;

  function frame(time){
    const t = Math.min((time-startTime)/duration,1);
    const pos = interpolateLatLng(startPos,newPos,t);
    const angle = lerp(startAngle,newAngle,t);
    mObj.marker.setLatLng(pos);
    mObj.marker.setRotationAngle(angle);
    mObj.currentPos = pos;
    mObj.currentAngle = angle;
    if(t<1) mObj.animFrame = requestAnimationFrame(frame);
    else mObj.animFrame = null;
  }
  if(mObj.animFrame) cancelAnimationFrame(mObj.animFrame);
  mObj.animFrame = requestAnimationFrame(frame);
}

// Obter informa√ß√µes do percurso via pattern_id
async function obterInfoPercurso(pattern_id){
  if(cachePatterns.has(pattern_id)) return cachePatterns.get(pattern_id);

  try{
    const resposta = await fetch(`https://api.carrismetropolitana.pt/patterns/${pattern_id}`);
    if(!resposta.ok) throw new Error("Erro ao obter percurso");
    const dados = await resposta.json();
    const headsign = dados?.headsign || "n√£o dispon√≠vel";
    const path = dados?.path || [];
    const paragens = path.map(p=>p.stop?.name).filter(Boolean).slice(0,5);
    const proximaParagem = path.find(p=>p.stop?.lat && p.stop?.lon)?.stop || null;
    const info = { headsign, paragens, proximaParagem };
    cachePatterns.set(pattern_id, info);
    return info;
  }catch(err){
    console.warn("Percurso n√£o dispon√≠vel:",err);
    const info = { headsign:"n√£o dispon√≠vel", paragens:[], proximaParagem:null };
    cachePatterns.set(pattern_id, info);
    return info;
  }
}

// Carregar dados reais da API
async function carregarAutocarros(){
  try{
    const veiculos = await fetch("https://api.carrismetropolitana.pt/vehicles")
      .then(res=>res.json());

    veiculos.forEach(async v=>{
      const {id,line_id,lat,lon,bearing,current_status,speed,timestamp,pattern_id} = v;
      if(!lat || !lon) return;

      const estado = traduzirStatus(current_status);
      const horaAtual = new Date(timestamp*1000).toLocaleTimeString("pt-PT",{hour12:false});
      const {headsign, paragens, proximaParagem} = await obterInfoPercurso(pattern_id);

      let tempoEstimado = "n√£o dispon√≠vel";
      const velocidadeKmH = speed ? Math.round(speed*3.6) : 0;
      if(proximaParagem && velocidadeKmH>0){
        const distKm = calcularDistanciaKm(lat,lon,proximaParagem.lat,proximaParagem.lon);
        const minutos = Math.round((distKm/velocidadeKmH)*60);
        tempoEstimado = `${minutos} min`;
      }

      const popupHTML = `
        üöå <strong>Autocarro ${id}</strong><br>
        <b>Linha:</b> ${line_id}<br>
        <b>Destino:</b> ${headsign}<br>
        <b>Velocidade:</b> ${velocidadeKmH} km/h<br>
        <b>Estado:</b> ${estado}<br>
        <b>Atualiza√ß√£o:</b> ${horaAtual}<br>
        <b>Tempo estimado at√© pr√≥xima paragem:</b> ${tempoEstimado}<br>
        <b>Pr√≥ximas paragens:</b><br>${paragens.join("<br>")}
      `;

      if(!marcadoresBuses.has(id)){
        const marker = L.marker([lat, lon],{
          icon: createBusSVGIcon(line_id),
          rotationAngle: bearing || 0,
          rotationOrigin:'center'
        }).addTo(map);
        marker.bindPopup(popupHTML);
        marcadoresBuses.set(id,{marker,currentPos:[lat,lon],currentAngle:bearing || 0,animFrame:null});
      } else {
        const mObj = marcadoresBuses.get(id);
        mObj.marker._popup.setContent(popupHTML);
        animateMarker(mObj,[lat,lon],bearing || 0,30000);
      }
    });

  }catch(err){
    console.error("Erro ao carregar autocarros:",err);
  }
}

// Atualiza a cada 30 segundos
carregarAutocarros();
setInterval(carregarAutocarros,30000);
</script>
</body>
</html>
